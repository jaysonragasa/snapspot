<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pictxel - Share Your World</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet.js (for OpenStreetMap) CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    
    <!-- Leaflet MarkerCluster CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://css.gg/css?family=Inter:400,500,600,700" rel="stylesheet">
    
    <!-- Custom Styles -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Ensure map takes full height */
        #map {
            height: 100vh;
            width: 100vw;
            z-index: 10;
        }
        /* Custom transition for modals */
        .modal-transition {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .modal-hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }
        .modal-visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        /* Base styles for custom markers */
        .custom-marker {
            border-radius: 9999px;
            padding: 6px;
            border: 2px solid white;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .custom-marker svg {
            width: 20px;
            height: 20px;
            color: white;
        }
        .camera-marker-icon {
            background: #2563eb; /* Tailwind blue-600 */
        }
        .note-marker-icon {
            background: #f97316; /* Tailwind orange-500 */
        }
        /* Custom image marker icon styles */
        .image-marker-icon {
            width: 55px;
            height: 55px;
            border-radius: 9999px; /* Circular */
            border: 5px solid white;
            background-color: #eee; /* Fallback color */
            box-shadow: 6px 6px 15px 0px rgb(0 0 0 / 0.4), 0 2px 4px -2px rgb(0 0 0 / 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        .image-marker-icon img {
            width: 100% !important;
            height: 100%;
            object-fit: cover;
        }
        /* Glassmorphism for Leaflet Controls */
        .leaflet-control-attribution, .leaflet-control-custom {
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            background: rgba(255, 255, 255, 0.6) !important;
            border-radius: 8px !important;
            border: 1px solid rgba(255, 255, 255, 0.4) !important;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1) !important;
        }
        .leaflet-control-custom {
            width: 34px !important;
            height: 34px !important;
        }
        .leaflet-control-custom a {
            color: black !important;
            background-color: transparent !important;
            border-radius: 6px;
        }
        .leaflet-control-custom a:hover {
            background-color: rgba(255, 255, 255, 0.4) !important;
        }
        .leaflet-control-attribution {
            padding: 2px 6px !important;
        }
         .leaflet-control-attribution a {
            color: #333 !important;
        }
        /* --- FIX for control visibility on mobile --- */
        .leaflet-top, .leaflet-bottom {
            z-index: 1001 !important;
        }
        /* --- Style overrides for Zoom controls --- */
        .leaflet-control-zoom {
            border: none !important;
            box-shadow: none !important;
            background: transparent !important;
            display: flex;
            flex-direction: column;
            gap: 8px; /* Creates space between + and - */
        }
        .leaflet-control-zoom a {
            width: 34px !important;
            height: 34px !important;
            line-height: 34px !important;
            text-align: center;
            text-decoration: none;
            color: black !important;
            /* Glassmorphism style, applied to each button */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            background: rgba(255, 255, 255, 0.6) !important;
            border-radius: 8px !important;
            border: 1px solid rgba(255, 255, 255, 0.4) !important;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1) !important;
        }
        .leaflet-control-zoom a:hover {
             background-color: rgba(255, 255, 255, 0.4) !important;
        }
        
        /* Custom popup style */
        .leaflet-popup-content-wrapper {
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        .leaflet-popup-content {
            margin: 12px !important;
            min-width: 150px;
        }
        .gallery-note-item {
            aspect-ratio: 1 / 1;
        }

        /* --- Bottom Sheet Styles --- */
        #bottom-sheet {
            transition: transform 0.3s ease-out;
            transform: translateY(100%);
        }
        #bottom-sheet.visible {
            transform: translateY(0);
        }
        #bottom-sheet-content {
            position: relative; /* Needed for virtual scrolling */
        }
        /* Custom scrollbar for horizontal scroll */
        #bottom-sheet-content::-webkit-scrollbar {
            height: 6px;
        }
        #bottom-sheet-content::-webkit-scrollbar-track {
            background: transparent;
        }
        #bottom-sheet-content::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }
        /* --- Notification Bar Styles --- */
        #notification-bar {
            top: 4.5rem; /* Position below the header */
            transform: scale(0.9) translateY(-150%);
            opacity: 0;
            transition: transform 0.4s ease, opacity 0.4s ease;
            pointer-events: none;
        }
        #notification-bar.visible {
            transform: scale(1) translateY(0);
            opacity: 1;
            pointer-events: auto;
        }
        /* --- Reaction Button Styles --- */
        .reaction-btn {
            transition: transform 0.2s ease;
        }
        .reaction-btn:hover {
            transform: scale(1.2);
        }
        .reaction-btn.selected {
            background-color: rgba(0, 123, 255, 0.2);
            border-radius: 9999px;
        }
    </style>
</head>
<body class="bg-gray-100 overflow-hidden">

    <!-- Main Map Container -->
    <div id="map"></div>

    <!-- Header / App Name -->
    <header class="absolute top-0 left-0 right-0 z-20 p-4 flex flex-col items-center gap-4 pointer-events-none">
        <div class="backdrop-blur-lg border border-white/40 rounded-full shadow-lg px-6 py-2 pointer-events-auto hidden">
            <h1 class="text-xl font-bold text-gray-800">Pictxel</h1>
        </div>
        <!-- Search Bar -->
        <div class="relative w-full max-w-md pointer-events-auto">
            <div id="search-container" class="w-full backdrop-blur-lg border border-white/40 rounded-full shadow-lg px-4 py-2 flex items-center gap-2">
                <span id="search-icon-container"></span>
                <input type="text" id="location-search-input" placeholder="Search for a location..." class="w-full bg-transparent outline-none text-gray-800 placeholder-gray-600">
                <button id="header-location-btn" class="p-1 rounded-full hover:bg-white/40 transition-colors">
                     <span id="header-location-icon-container"></span>
                </button>
            </div>
            <div id="search-results" class="absolute top-full mt-2 w-full bg-white/50 backdrop-blur-lg border border-white/40 rounded-xl shadow-lg overflow-hidden hidden z-50">
                <!-- Search results go here -->
            </div>
        </div>
    </header>

     <!-- Notification Bar -->
    <div id="notification-bar" class="fixed left-0 right-0 z-50 flex justify-center">
        <div class="backdrop-blur-lg bg-white/50 border border-white/40 rounded-full shadow-lg px-4 pl-6 py-2 flex items-center gap-4">
            <p id="notification-message" class="text-gray-800 text-center text-sm"></p>
            <button id="close-notification-btn" class="text-gray-500 hover:text-gray-800">
                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
            </button>
        </div>
    </div>

    <!-- Bottom Sheet -->
    <div id="bottom-sheet" class="fixed bottom-0 left-0 right-0 z-20 p-4 pointer-events-none">
        <div class="w-full bg-white/50 backdrop-blur-lg border border-white/40 rounded-xl shadow-2xl p-3 pointer-events-auto">
            <div id="bottom-sheet-content" class="flex gap-3 overflow-x-auto pb-2">
                <!-- Virtual scrolling content will be managed by JS -->
            </div>
        </div>
    </div>

    <!-- Upload Modal -->
    <div id="upload-modal" class="modal-transition modal-hidden fixed inset-0 bg-opacity-50 backdrop-blur-sm flex items-center justify-center z-30 p-4">
        <div class="bg-white/50 backdrop-blur-lg border border-white/40 rounded-2xl shadow-2xl p-6 md:p-8 w-full max-w-md mx-auto transform">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800">Share a New Spot</h2>
                <button id="close-modal-button" class="text-gray-500 hover:text-gray-800">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            
            <form id="upload-form">
                <div class="space-y-4">
                    
                    <!-- File Upload Buttons -->
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Add a Photo (Optional)</label>
                        <div class="mt-1 grid grid-cols-2 gap-4">
                            <button type="button" id="camera-upload-btn" class="flex flex-col items-center justify-center p-4 bg-white/60 border border-gray-300 rounded-md shadow-sm hover:bg-gray-50/80 transition-colors">
                                <span id="camera-icon-container"></span>
                                <span class="mt-2 text-sm font-medium text-gray-700">Use Camera</span>
                            </button>
                             <button type="button" id="photo-upload-btn" class="flex flex-col items-center justify-center p-4 bg-white/60 border border-gray-300 rounded-md shadow-sm hover:bg-gray-50/80 transition-colors">
                                <span id="photo-icon-container"></span>
                                <span class="mt-2 text-sm font-medium text-gray-700">Upload Photo</span>
                            </button>
                        </div>
                        <input type="file" id="photo" name="photo" accept="image/*" class="hidden">
                        <div id="file-preview" class="mt-2 text-sm text-gray-600"></div>
                    </div>

                    <!-- Uploader's Name -->
                    <div>
                        <label for="uploaderName" class="block text-sm font-medium text-gray-700">Your Name</label>
                        <input type="text" id="uploaderName" name="uploaderName" required placeholder="What should we call you?" class="mt-1 block w-full px-3 py-2 bg-white/80 border border-gray-300 rounded-md shadow-sm placeholder-gray-500 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    </div>
                    
                    <!-- Description -->
                    <div>
                        <label for="description" class="block text-sm font-medium text-gray-700">Description or Note</label>
                        <textarea id="description" name="description" rows="3" required class="mt-1 block w-full px-3 py-2 bg-white/80 border border-gray-300 rounded-md shadow-sm placeholder-gray-500 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"></textarea>
                    </div>

                    <!-- Hidden fields for coordinates -->
                    <input type="hidden" id="latitude" name="latitude">
                    <input type="hidden" id="longitude" name="longitude">

                </div>
				<div class="mt-4">
                    <p class="text-xs text-gray-600 text-center">
                        Note: We securely store your uploaded images and never share or sell them to third parties. A watermark with your provided name will be added to each image. Please ensure you have the right to upload the content, as you are responsible for it. The location where you tap on the map is saved to place the spot correctly.
                    </p>
                </div>
                <div class="mt-6">
                    <button type="submit" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 transition-all duration-150 ease-in-out disabled:bg-gray-400">
                        Upload Spot
                    </button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Full-Screen Image Viewer Modal -->
    <div id="image-viewer" class="modal-transition modal-hidden fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-40 p-4">
        <div class="relative w-full h-full flex flex-col items-center justify-center pointer-events-none">
             <button id="close-viewer-btn" class="absolute top-4 right-4 text-white/80 hover:text-white z-50 pointer-events-auto">
                <svg class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <img id="viewer-img" src="" class="max-h-[70%] max-w-[90vw] object-contain rounded-lg shadow-2xl pointer-events-auto">
            <div id="viewer-info" class="w-full max-w-3xl text-white text-center mt-4 p-4 bg-black/40 backdrop-blur-md rounded-lg pointer-events-auto"></div>
        </div>
    </div>

    <!-- Gallery Modal -->
    <div id="gallery-modal" class="modal-transition modal-hidden fixed inset-0 bg-black/90 backdrop-blur-sm z-40 p-4 overflow-y-auto">
        <div class="relative w-full max-w-6xl mx-auto pb-24">
            <button id="close-gallery-btn" class="fixed top-4 right-4 text-white/80 hover:text-white z-50">
                 <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <h2 class="text-3xl font-bold text-white text-center my-4">Cluster Gallery</h2>
            <div id="gallery-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4"></div>
        </div>
    </div>
    
    <!-- Firebase and Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    
    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, doc, updateDoc, serverTimestamp, increment, getDoc, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        /**
         * @module Config
         * Centralized configuration for the application.
         */
        const Config = {
            // Use environment's config if available, otherwise fall back to user-provided config
            firebase: typeof __firebase_config !== 'undefined' 
                ? JSON.parse(__firebase_config) 
                : {
                    apiKey: "%VITE_FIREBASE_API_KEY%",
					authDomain: "%VITE_FIREBASE_AUTH_DOMAIN%",
					projectId: "%VITE_FIREBASE_PROJECT_ID%",
					storageBucket: "%VITE_FIREBASE_STORAGE_BUCKET%",
					messagingSenderId: "%VITE_FIREBASE_MESSAGING_SENDER_ID%",
					appId: "%VITE_FIREBASE_APP_ID%",
					measurementId: "%VITE_FIREBASE_MEASUREMENT_ID%"
                },
            appId: typeof __app_id !== 'undefined' ? __app_id : 'pictxel-default',
            initialAuthToken: typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null,
            map: {
                initialCoords: [14.5995, 120.9842], // Manila
                initialZoom: 13,
                maxZoom: 19,
                tileLayer: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                useImageAsMarker: true, // Global toggle for marker style
                maxClusterRadius: 80 // Default is 80. Smaller = more clusters, larger = fewer clusters.
            },
            api: {
                reverseGeocode: 'https://api.bigdatacloud.net/data/reverse-geocode-client'
            },
            imageProcessing: {
                maxDimension: 1024,
                jpegQuality: 0.9
            },
            icons: {
                // Icons for map markers
                cameraMarker: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a2.5 2.5 0 100-5 2.5 2.5 0 000 5z" clip-rule="evenodd" /></svg>`,
                noteMarker: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M5.433 13.917l1.262-3.155A4 4 0 017.58 9.42l6.92-6.918a2.121 2.121 0 013 3l-6.92 6.918c-.383.383-.84.685-1.343.886l-3.154 1.262a.5.5 0 01-.65-.65z" /><path d="M3.5 5.75c0-.69.56-1.25 1.25-1.25H10A.75.75 0 0010 3H4.75A2.75 2.75 0 002 5.75v9.5A2.75 2.75 0 004.75 18h9.5A2.75 2.75 0 0017 15.25V10a.75.75 0 00-1.5 0v5.25c0 .69-.56 1.25-1.25 1.25h-9.5c-.69 0-1.25-.56-1.25-1.25v-9.5z" /></svg>`,
                // Icon for "Current Location" button
                location: `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></svg>`,
                // Icons for upload form
                uploadCamera: `<svg class="h-8 w-8 text-gray-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a2.5 2.5 0 100-5 2.5 2.5 0 000 5z" clip-rule="evenodd" /></svg>`,
                uploadPhoto: `<svg class="h-8 w-8 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" /></svg>`,
                search: `<svg class="h-5 w-5 text-gray-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>`
            }
        };

        /**
         * @module Utils
         * Helper functions for various tasks.
         */
        const Utils = {
            truncateText(str, n) {
                if (!str) return '';
                return (str.length > n) ? str.slice(0, n - 1) + '...' : str;
            },
            getRandomHexColor() {
                const letters = '0123456789ABCDEF';
                let color = '#';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            },
            getContrastColor(hex) {
                if (!hex) return '#000000';
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                // http://www.w3.org/TR/AERT#color-contrast
                const brightness = Math.round(((r * 299) + (g * 587) + (b * 114)) / 1000);
                return (brightness > 125) ? '#000000' : '#FFFFFF';
            }
        };

        /**
         * @module FirebaseService
         * Handles all interactions with Firebase services (Auth, Firestore).
         */
        const FirebaseService = {
            app: null,
            auth: null,
            db: null,
            userId: null,

            async init(onAuthStateChangeCallback) {
                try {
                    this.app = initializeApp(Config.firebase);
                    this.auth = getAuth(this.app);
                    this.db = getFirestore(this.app);

                    onAuthStateChanged(this.auth, (user) => {
                        if (user) {
                            this.userId = user.uid;
                            console.log("User authenticated:", this.userId);
                            onAuthStateChangeCallback(this.userId);
                        }
                    });

                    if (Config.initialAuthToken) {
                        await signInWithCustomToken(this.auth, Config.initialAuthToken);
                    } else {
                        await signInAnonymously(this.auth);
                    }
                } catch (error) {
                    console.error("Firebase initialization failed:", error);
                }
            },

            listenForSpots(callback) {
                const spotsCollection = collection(this.db, 'artifacts', Config.appId, 'public', 'data', 'spots');
                onSnapshot(spotsCollection, callback);
            },

            async saveSpot(spotData) {
                if (!this.userId) throw new Error("User not authenticated.");
                const spotsCollection = collection(this.db, 'artifacts', Config.appId, 'public', 'data', 'spots');
                return addDoc(spotsCollection, {
                    ...spotData,
                    authorId: this.userId,
                    createdAt: serverTimestamp(),
                    reactions: { thumbsUp: 0, thumbsDown: 0, heart: 0, heartEyes: 0, laugh: 0, shocked: 0, sad: 0, angry: 0, evil: 0 },
                    voters: {}
                });
            },

            async getSpot(spotId) {
                 const spotRef = doc(this.db, 'artifacts', Config.appId, 'public', 'data', 'spots', spotId);
                 return getDoc(spotRef);
            },

            async updateReaction(spotId, newReaction, previousReaction) {
                 if (!this.userId) throw new Error("User not authenticated for voting.");
                 const spotRef = doc(this.db, 'artifacts', Config.appId, 'public', 'data', 'spots', spotId);
                 const updatePayload = {};
                 
                 // User is un-reacting
                 if (newReaction === previousReaction) {
                     updatePayload[`reactions.${newReaction}`] = increment(-1);
                     updatePayload[`voters.${this.userId}`] = deleteField();
                 } 
                 // User is changing their reaction
                 else if (previousReaction) {
                     updatePayload[`reactions.${previousReaction}`] = increment(-1);
                     updatePayload[`reactions.${newReaction}`] = increment(1);
                     updatePayload[`voters.${this.userId}`] = newReaction;
                 }
                 // User is casting a new reaction
                 else {
                     updatePayload[`reactions.${newReaction}`] = increment(1);
                     updatePayload[`voters.${this.userId}`] = newReaction;
                 }
                 
                 return updateDoc(spotRef, updatePayload);
            }
        };

        /**
         * @module MapService
         * Manages the Leaflet map instance and its layers.
         */
        const MapService = {
            map: null,
            markers: null,
            userLocationMarker: null,

            init(onMapClick, onClusterClick, onMapMove) {
                this.map = L.map('map', { zoomControl: false }).setView(Config.map.initialCoords, Config.map.initialZoom);
                L.control.zoom({ position: 'topleft' }).addTo(this.map);
                
                L.tileLayer(Config.map.tileLayer, {
                    maxZoom: Config.map.maxZoom,
                    attribution: Config.map.attribution
                }).addTo(this.map);
                
                this.markers = L.markerClusterGroup({
                    zoomToBoundsOnClick: false, // Disable default zoom behavior
                    maxClusterRadius: Config.map.maxClusterRadius
                });
                this.map.addLayer(this.markers);

                this.map.on('click', onMapClick);
                this.map.on('moveend', onMapMove);
                this.markers.on('clusterclick', onClusterClick);
            },

            renderSpots(spots) {
                this.markers.clearLayers();
                const newMarkers = [];
                spots.forEach(spot => {
                    if (spot.data.location && spot.data.location.latitude && spot.data.location.longitude) {
                        let iconHtml;
                        let iconClassName = '';
                        let iconSize = [36, 36];
                        let iconAnchor = [18, 18];

                        if (spot.data.spotType === 'note') {
                            iconHtml = `<div class="custom-marker note-marker-icon">${Config.icons.noteMarker}</div>`;
                        } else if (Config.map.useImageAsMarker && spot.data.photoDataUrl) {
                            iconHtml = `<div class="image-marker-icon"><img src="${spot.data.photoDataUrl}" alt="Spot thumbnail"></div>`;
                            iconSize = [55, 55];
                            iconAnchor = [27, 27];
                        } else {
                            iconHtml = `<div class="custom-marker camera-marker-icon">${Config.icons.cameraMarker}</div>`;
                        }
                        
                        const customIcon = L.divIcon({
                            html: iconHtml,
                            className: iconClassName,
                            iconSize: iconSize,
                            iconAnchor: iconAnchor
                        });

                        const marker = L.marker([spot.data.location.latitude, spot.data.location.longitude], {
                            icon: customIcon,
                            spotId: spot.id,
                            spotData: spot.data
                        });
                        
                        let popupContent = '';
                        if (spot.data.spotType === 'note') {
                            popupContent = `
                                <div class="p-1 cursor-pointer popup-note" data-spot-id="${spot.id}">
                                    <p class="font-semibold text-gray-800">${spot.data.uploaderName}</p>
                                    <p class="text-gray-600">${Utils.truncateText(spot.data.description, 100)}</p>
                                    <p class="text-xs text-blue-500 mt-1">Click to view full note</p>
                                </div>`;
                        } else {
                            popupContent = `
                                <div class="text-center">
                                    <img src="${spot.data.photoDataUrl}" alt="${spot.data.description || 'Spot image'}" class="w-full h-auto rounded-md cursor-pointer popup-image" style="max-width: 200px; max-height: 200px; object-fit: cover;" data-spot-id="${spot.id}">
                                    <p class="mt-2 text-sm text-gray-700">${Utils.truncateText(spot.data.description, 50) || 'Click image to view full size.'}</p>
                                </div>`;
                        }

                        marker.bindPopup(popupContent);

                        marker.on('popupopen', (e) => {
                            const popup = e.popup;
                            const img = popup.getElement().querySelector('.popup-image');
                            if (img && !img.complete) {
                                img.onload = () => {
                                    popup.update();
                                }
                            }
                        });

                        newMarkers.push(marker);
                    }
                });
                this.markers.addLayers(newMarkers);
            },

            panTo(location, zoom = 18) {
                this.map.flyTo([location.latitude, location.longitude], zoom);
            },
            
            showUserLocationMarker(location) {
                if (this.userLocationMarker) {
                    this.map.removeLayer(this.userLocationMarker);
                }
                this.userLocationMarker = L.circleMarker([location.latitude, location.longitude], {
                    radius: 8,
                    fillColor: "#2563eb",
                    color: "#fff",
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(this.map);

                setTimeout(() => {
                    if (this.userLocationMarker) {
                        this.map.removeLayer(this.userLocationMarker);
                        this.userLocationMarker = null;
                    }
                }, 10000);
            }
        };

        /**
         * @module UIService
         * Handles DOM manipulations and UI event listeners.
         */
        const UIService = {
            uploadModal: null, closeModalButton: null, uploadForm: null, latInput: null, lonInput: null,
            imageViewer: null, closeViewerBtn: null, viewerImg: null, viewerInfo: null,
            galleryModal: null, closeGalleryBtn: null, galleryGrid: null,
            photoInput: null, filePreview: null,
            searchResultsContainer: null,
            bottomSheet: null, 
            bottomSheetContent: null,
            notificationBar: null, notificationMessage: null, closeNotificationBtn: null,
            
            init(onFormSubmit) {
                // Upload Modal
                this.uploadModal = document.getElementById('upload-modal');
                this.closeModalButton = document.getElementById('close-modal-button');
                this.uploadForm = document.getElementById('upload-form');
                this.latInput = document.getElementById('latitude');
                this.lonInput = document.getElementById('longitude');
                this.photoInput = document.getElementById('photo');
                this.filePreview = document.getElementById('file-preview');
                const cameraBtn = document.getElementById('camera-upload-btn');
                const photoBtn = document.getElementById('photo-upload-btn');
                
                // Image Viewer
                this.imageViewer = document.getElementById('image-viewer');
                this.closeViewerBtn = document.getElementById('close-viewer-btn');
                this.viewerImg = document.getElementById('viewer-img');
                this.viewerInfo = document.getElementById('viewer-info');
                
                // Gallery Modal
                this.galleryModal = document.getElementById('gallery-modal');
                this.closeGalleryBtn = document.getElementById('close-gallery-btn');
                this.galleryGrid = document.getElementById('gallery-grid');
                
                // Search
                this.searchResultsContainer = document.getElementById('search-results');
                
                // Bottom Sheet
                this.bottomSheet = document.getElementById('bottom-sheet');
                this.bottomSheetContent = document.getElementById('bottom-sheet-content');

                // Notification Bar
                this.notificationBar = document.getElementById('notification-bar');
                this.notificationMessage = document.getElementById('notification-message');
                this.closeNotificationBtn = document.getElementById('close-notification-btn');

                // Populate Icon Containers
                document.getElementById('camera-icon-container').innerHTML = Config.icons.uploadCamera;
                document.getElementById('photo-icon-container').innerHTML = Config.icons.uploadPhoto;
                document.getElementById('search-icon-container').innerHTML = Config.icons.search;
                document.getElementById('header-location-icon-container').innerHTML = Config.icons.location;

                // Event Listeners
                this.closeModalButton.addEventListener('click', () => this.toggleUploadModal(false));
                this.uploadModal.addEventListener('click', (e) => {
                    if (e.target === this.uploadModal) this.toggleUploadModal(false);
                });
                this.uploadForm.addEventListener('submit', onFormSubmit);

                this.closeViewerBtn.addEventListener('click', () => this.toggleImageViewer(false));
                this.imageViewer.addEventListener('click', (e) => {
                    if (e.target === this.imageViewer) this.toggleImageViewer(false);
                });
                this.closeGalleryBtn.addEventListener('click', () => this.toggleGallery(false));
                
                cameraBtn.addEventListener('click', () => {
                    this.photoInput.removeAttribute('capture');
                    this.photoInput.setAttribute('capture', 'environment');
                    this.photoInput.click();
                });

                photoBtn.addEventListener('click', () => {
                    this.photoInput.removeAttribute('capture');
                    this.photoInput.click();
                });

                this.photoInput.addEventListener('change', (e) => {
                    if (e.target.files && e.target.files[0]) {
                        this.filePreview.textContent = `Selected: ${e.target.files[0].name}`;
                    } else {
                        this.filePreview.textContent = '';
                    }
                });
            },

            toggleUploadModal(show, latlng = null) {
                if (show && latlng) {
                    this.latInput.value = latlng.lat;
                    this.lonInput.value = latlng.lng;
                    const savedName = localStorage.getItem('pictxel_uploader_name');
                    if (savedName) this.uploadForm.uploaderName.value = savedName;
                    this.uploadModal.classList.remove('modal-hidden');
                    this.uploadModal.classList.add('modal-visible');
                } else {
                    this.uploadModal.classList.add('modal-hidden');
                    this.uploadModal.classList.remove('modal-visible');
                    this.uploadForm.reset();
                    this.filePreview.textContent = '';
                }
            },

            toggleImageViewer(show, spotId = null, spot = null, onShowOnMap = () => {}) {
                 if (show && spot && spotId) {
                    const locationHtml = (spot.city && spot.city !== 'Unknown') || (spot.country && spot.country !== 'Unknown')
                        ? `<p class="text-xs text-gray-400 mt-1">${spot.city}, ${spot.country}</p>`
                        : '';
                    
                    const showOnMapBtnId = `show-on-map-${spotId}`;
                    this.viewerInfo.innerHTML = `
                        <h3 class="font-bold text-lg">${spot.uploaderName}</h3>
                        <p class="text-gray-300 text-sm mt-1">${spot.description || ''}</p>
                        ${locationHtml}
                        <div id="reaction-bar" class="mt-3 flex items-center justify-center text-lg space-x-2">
                           ${this.generateReactionsHtml(spotId, spot)}
                        </div>
                        <button id="${showOnMapBtnId}" class="text-blue-400 hover:text-blue-300 text-sm mt-3">Show on Map</button>
                        `;
                    
                    if (spot.spotType === 'note') {
                        this.viewerImg.style.display = 'none';
                    } else {
                        this.viewerImg.style.display = 'block';
                        this.viewerImg.src = spot.photoDataUrl;
                    }

                    // Attach event listener for the new button
                     setTimeout(() => { // Use timeout to ensure element exists in DOM
                        document.getElementById(showOnMapBtnId).addEventListener('click', () => {
                            this.toggleImageViewer(false);
                            onShowOnMap(spot.location);
                        });
                     }, 0);

                    this.imageViewer.classList.remove('modal-hidden');
                    this.imageViewer.classList.add('modal-visible');
                } else {
                    this.imageViewer.classList.add('modal-hidden');
                    this.imageViewer.classList.remove('modal-visible');
                    this.viewerImg.src = "";
                    this.viewerInfo.innerHTML = "";
                }
            },

            generateReactionsHtml(spotId, spot) {
                const currentUserVote = spot.voters ? spot.voters[FirebaseService.userId] : null;
                return Object.entries(App.REACTIONS).map(([key, emoji]) => {
                    const count = (spot.reactions && spot.reactions[key]) || 0;
                    const selectedClass = currentUserVote === key ? 'selected' : '';
                    return `
                        <button data-spot-id="${spotId}" data-reaction="${key}" class="reaction-btn ${selectedClass}">
                            <span class="text-xl">${emoji}</span>
                            <span class="text-xs">${count}</span>
                        </button>
                    `;
                }).join('');
            },

            toggleGallery(show, spots = [], onSpotClick) {
                 if (show) {
                    this.galleryGrid.innerHTML = ''; // Clear previous items
                    spots.forEach(spot => {
                        let galleryItem;
                        if (spot.data.spotType === 'note') {
                            galleryItem = document.createElement('div');
                            const bgColor = Utils.getRandomHexColor();
                            const textColor = Utils.getContrastColor(bgColor);
                            
                            galleryItem.className = 'gallery-note-item w-full h-full rounded-lg cursor-pointer hover:opacity-80 transition-opacity flex items-center justify-center p-2 text-center text-sm';
                            galleryItem.style.backgroundColor = bgColor;
                            galleryItem.style.color = textColor;
                            galleryItem.textContent = Utils.truncateText(spot.data.description, 50);
                        } else {
                            galleryItem = document.createElement('img');
                            galleryItem.src = spot.data.photoDataUrl;
                            galleryItem.className = 'w-full h-full object-cover rounded-lg cursor-pointer hover:opacity-80 transition-opacity';
                        }
                        
                        galleryItem.addEventListener('click', () => {
                            this.toggleGallery(false);
                            onSpotClick(spot.id, spot.data);
                        });
                        this.galleryGrid.appendChild(galleryItem);
                    });
                    this.galleryModal.classList.remove('modal-hidden');
                    this.galleryModal.classList.add('modal-visible');
                } else {
                    this.galleryModal.classList.add('modal-hidden');
                    this.galleryModal.classList.remove('modal-visible');
                    this.galleryGrid.innerHTML = '';
                }
            },
            
            getFormData() {
                const formData = new FormData(this.uploadForm);
                return {
                    uploaderName: formData.get('uploaderName'),
                    description: formData.get('description'),
                    photo: formData.get('photo'),
                    latitude: parseFloat(formData.get('latitude')),
                    longitude: parseFloat(formData.get('longitude')),
                };
            },

            setFormSubmitting(isSubmitting, message = 'Upload Spot') {
                const submitButton = this.uploadForm.querySelector('button[type="submit"]');
                submitButton.disabled = isSubmitting;
                submitButton.textContent = message;
            },

            displaySearchResults(results, onResultClick) {
                this.searchResultsContainer.innerHTML = '';
                this.searchResultsContainer.classList.remove('hidden');

                if (!results || results.length === 0) {
                    this.searchResultsContainer.innerHTML = `<div class="p-4 text-sm text-gray-600">No results found.</div>`;
                    return;
                }

                results.forEach(result => {
                    const item = document.createElement('div');
                    item.className = 'p-3 border-b border-white/20 cursor-pointer hover:bg-white/20 text-gray-800 text-sm';
                    item.innerHTML = result.name;
                    item.addEventListener('click', () => onResultClick(result));
                    this.searchResultsContainer.appendChild(item);
                });
            },

            hideSearchResults() {
                this.searchResultsContainer.innerHTML = '';
                this.searchResultsContainer.classList.add('hidden');
            },

            updateBottomSheet(spots, onSpotClick) {
                // This is a placeholder for the future virtual scroller
                const limitedSpots = spots.slice(0, 50); // Hard limit for now

                if (!this.bottomSheet || !this.bottomSheetContent) return;

                this.bottomSheetContent.innerHTML = ''; 

                if (limitedSpots.length === 0) {
                    this.bottomSheet.classList.remove('visible');
                    return;
                }

                this.bottomSheet.classList.add('visible');

                limitedSpots.forEach(spot => {
                    let sheetItem;
                    if (spot.data.spotType === 'note') {
                        sheetItem = document.createElement('div');
                        const bgColor = Utils.getRandomHexColor();
                        const textColor = Utils.getContrastColor(bgColor);
                        
                        sheetItem.className = 'flex-shrink-0 w-24 h-24 rounded-lg cursor-pointer hover:opacity-80 transition-opacity flex items-center justify-center p-2 text-center text-xs';
                        sheetItem.style.backgroundColor = bgColor;
                        sheetItem.style.color = textColor;
                        sheetItem.textContent = Utils.truncateText(spot.data.description, 40);
                    } else {
                        sheetItem = document.createElement('img');
                        sheetItem.src = spot.data.photoDataUrl;
                        sheetItem.className = 'flex-shrink-0 w-24 h-24 object-cover rounded-lg cursor-pointer hover:opacity-80 transition-opacity';
                    }
                    
                    sheetItem.addEventListener('click', () => {
                        onSpotClick(spot.id, spot.data);
                    });
                    this.bottomSheetContent.appendChild(sheetItem);
                });
            },

            toggleNotification(show, message) {
                if(show) {
                    this.notificationMessage.textContent = message;
                    this.notificationBar.classList.add('visible');
                } else {
                    this.notificationBar.classList.remove('visible');
                }
            }
        };

        /**
         * @module ImageProcessor
         * Handles client-side image manipulation.
         */
        const ImageProcessor = {
            process(file, watermarkText) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = this.createWatermarkedCanvas(img, watermarkText);
                            canvas.toBlob((blob) => {
                                if (blob) resolve(blob);
                                else reject(new Error('Canvas to Blob conversion failed'));
                            }, 'image/jpeg', Config.imageProcessing.jpegQuality);
                        };
                        img.onerror = () => reject(new Error('Image loading failed'));
                        img.src = e.target.result;
                    };
                    reader.onerror = () => reject(new Error('File reading failed'));
                    reader.readAsDataURL(file);
                });
            },

            createWatermarkedCanvas(img, watermarkText) {
                const { maxDimension } = Config.imageProcessing;
                let { width, height } = img;
                if (width > height) {
                    if (width > maxDimension) {
                        height *= maxDimension / width;
                        width = maxDimension;
                    }
                } else {
                    if (height > maxDimension) {
                        width *= maxDimension / height;
                        height = maxDimension;
                    }
                }

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                // Watermark drawing logic
                const fontSize = height * 0.04;
                ctx.font = `bold ${fontSize}px Inter, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const textMetrics = ctx.measureText(watermarkText);
                const padding = fontSize * 0.5;
                const rectWidth = textMetrics.width + padding * 2;
                const rectHeight = fontSize + padding;
                const rectX = (width - rectWidth) / 2;
                const rectY = height - rectHeight - (height * 0.03);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.roundRect(rectX, rectY, rectWidth, rectHeight, [rectHeight / 2]);
                ctx.fill();

                ctx.fillStyle = '#FFFFFF';
                ctx.fillText(watermarkText, width / 2, rectY + rectHeight / 2);
                
                return canvas;
            },
            
            blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }
        };

        /**
         * @module APIService
         * Handles external API calls.
         */
        const APIService = {
            async getGeolocationData(lat, lon) {
                try {
                    const response = await fetch(`${Config.api.reverseGeocode}?latitude=${lat}&longitude=${lon}&localityLanguage=en`);
                    if (!response.ok) throw new Error(`API call failed with status: ${response.status}`);
                    
                    const data = await response.json();
                    const country = (data.countryName || 'Unknown').replace(' (the)', '');
                    return { country, city: data.city || data.locality || 'Unknown' };
                } catch (error) {
                    console.error("Geolocation lookup failed:", error);
                    return { country: 'Unknown', city: 'Unknown' };
                }
            }
        };

        /**
         * @module App
         * Main application controller. Initializes and orchestrates all modules.
         */
        const App = {
            spotsData: new Map(),
            notificationTimeout: null,
            REACTIONS: {
                thumbsUp: '',
                thumbsDown: '',
                heart: '',
                heartEyes: '',
                laugh: '',
                shocked: '',
                sad: '',
                angry: '',
                evil: ''
            },
            
            init() {
                FirebaseService.init(this.onAuthStateChange.bind(this));
                MapService.init(this.onMapClick.bind(this), this.onClusterClick.bind(this), this.updateBottomSheet.bind(this));
                UIService.init(this.handleUpload.bind(this));
                this.setupHeaderControls();
                this.setupReactionHandler();
                this.setupPopupImageClickHandler();
                this.setupPopupNoteClickHandler();
                UIService.closeNotificationBtn.addEventListener('click', () => this.hideNotification());
                this.showCurrentUserLocation();
            },

            onAuthStateChange(userId) {
                FirebaseService.listenForSpots(this.onSpotsUpdate.bind(this));
            },

            onSpotsUpdate(snapshot) {
                const spots = [];
                this.spotsData.clear();
                snapshot.forEach(doc => {
                    const spot = { id: doc.id, data: doc.data() };
                    spots.push(spot);
                    this.spotsData.set(spot.id, spot.data);
                });
                MapService.renderSpots(spots);
                this.updateBottomSheet(); // Update sheet on initial load and when new spots are added
            },

            onMapClick(e) {
                // A robust check to see if a popup is open.
                // We check the map's popup pane for any child elements.
                const popupPane = MapService.map.getPane('popupPane');
                if (popupPane && popupPane.hasChildNodes()) {
                    MapService.map.closePopup();
                    return;
                }
                UIService.toggleUploadModal(true, e.latlng);
            },

            onMarkerClick(spotId, spotData) {
                UIService.toggleImageViewer(true, spotId, spotData, this.onShowOnMap.bind(this));
            },

            onClusterClick(e) {
                const markers = e.layer.getAllChildMarkers();
                const spots = markers
                    .map(marker => ({ id: marker.options.spotId, data: marker.options.spotData }))
                    .filter(spot => spot.data);
                
                if (spots.length > 0) {
                    UIService.toggleGallery(true, spots, this.onMarkerClick.bind(this));
                }
            },
            
            onShowOnMap(location) {
                MapService.panTo(location);
            },
            
            showCurrentUserLocation() {
                if (!navigator.geolocation) {
                    this.showNotification("Geolocation is not supported by your browser.", null);
                    return;
                }

                this.showNotification("Zooming to your current location");

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        MapService.panTo({ latitude: lat, longitude: lng }, 19);
                        MapService.showUserLocationMarker({ latitude: lat, longitude: lng });
                    },
                    () => {
                        this.showNotification("Unable to retrieve your location.", null);
                    }
                );
            },

            async handleUpload(e) {
                e.preventDefault();
                
                try {
                    const { uploaderName, description, photo, latitude, longitude } = UIService.getFormData();
                    
                    if (!description.trim()) {
                        alert("Please add a description or note.");
                        return;
                    }

                    UIService.setFormSubmitting(true, 'Processing...');
                    localStorage.setItem('pictxel_uploader_name', uploaderName);

                    let photoDataUrl = null;
                    let spotType = 'note';

                    if (photo && photo.size > 0) {
                        spotType = 'image';
                        console.log("Step 1a: Processing image...");
                        const imageBlob = await ImageProcessor.process(photo, uploaderName);
                        photoDataUrl = await ImageProcessor.blobToBase64(imageBlob);
                        console.log("Step 2: Image processed and converted.");
                    }
                    
                    console.log("Step 1b: Fetching location...");
                    const locationData = await APIService.getGeolocationData(latitude, longitude);
                    console.log("Step 3: Location data ready.");
                    
                    UIService.setFormSubmitting(true, 'Saving...');

                    await FirebaseService.saveSpot({
                        uploaderName,
                        description,
                        photoDataUrl,
                        spotType,
                        location: { latitude, longitude },
                        country: locationData.country,
                        city: locationData.city,
                    });
                    
                    console.log("Step 4: Spot saved to Firestore! All done.");
                    UIService.toggleUploadModal(false);
                    this.showNotification("Your spot has been saved successfully!");

                } catch (error) {
                    console.error("Upload failed:", error);
                    alert("Something went wrong while saving your spot. Please try again.");
                } finally {
                    UIService.setFormSubmitting(false, 'Upload Spot');
                }
            },
            
            setupHeaderControls() {
                const searchInput = document.getElementById('location-search-input');
                const locationBtn = document.getElementById('header-location-btn');
                const searchContainer = document.getElementById('search-container').parentElement; // The new relative wrapper

                locationBtn.addEventListener('click', () => {
                    this.showCurrentUserLocation();
                });

                searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const query = searchInput.value;
                        if (query) {
                            this.handleLocationSearch(query);
                        }
                    }
                });
                
                // Add a global listener to close results when clicking outside
                document.addEventListener('click', (e) => {
                    if (!searchContainer.contains(e.target)) {
                        UIService.hideSearchResults();
                    }
                });
            },

            async handleLocationSearch(query) {
                const url = new URL('https://nominatim.openstreetmap.org/search');
                url.searchParams.append('q', query);
                url.searchParams.append('format', 'json');
                url.searchParams.append('limit', 10);
                url.searchParams.append('polygon_geojson', 1);

                try {
                    const response = await fetch(url);
                    const data = await response.json();

                    const results = data.map(item => {
                        const [south, north, west, east] = item.boundingbox;
                        return {
                            name: item.display_name,
                            bbox: L.latLngBounds(L.latLng(south, west), L.latLng(north, east)),
                            center: L.latLng(item.lat, item.lon)
                        };
                    });

                    UIService.displaySearchResults(results, this.onSearchResultClick.bind(this));
                } catch (error) {
                    console.error("Error fetching location data:", error);
                    alert("Could not perform search. Please check your connection.");
                }
            },
            
            onSearchResultClick(result) {
                const bbox = result.bbox;
                const poly = L.polygon([
                    bbox.getSouthEast(),
                    bbox.getNorthEast(),
                    bbox.getNorthWest(),
                    bbox.getSouthWest()
                ]);
                MapService.map.fitBounds(poly.getBounds());
                UIService.hideSearchResults();
                document.getElementById('location-search-input').value = ''; // Clear input
            },

            updateBottomSheet() {
                const bounds = MapService.map.getBounds();
                const visibleSpots = [];
                // We need to iterate through the actual marker layers, not the cluster group
                MapService.markers.eachLayer(layer => {
                    // Check if it's a marker and within the bounds
                    if (layer instanceof L.Marker && bounds.contains(layer.getLatLng())) {
                         if(layer.options.spotData) {
                             visibleSpots.push({id: layer.options.spotId, data: layer.options.spotData});
                         }
                    }
                });
                UIService.updateBottomSheet(visibleSpots, this.onMarkerClick.bind(this));
            },
            
            showNotification(message, duration = 5000) {
                if (this.notificationTimeout) {
                    clearTimeout(this.notificationTimeout);
                }
                UIService.toggleNotification(true, message);
                if (duration) {
                    this.notificationTimeout = setTimeout(() => {
                        this.hideNotification();
                    }, duration);
                }
            },

            hideNotification() {
                if (this.notificationTimeout) {
                    clearTimeout(this.notificationTimeout);
                    this.notificationTimeout = null;
                }
                UIService.toggleNotification(false);
            },

            setupPopupImageClickHandler() {
                document.addEventListener('click', (e) => {
                    const popupImage = e.target.closest('.popup-image');
                    if (!popupImage) return;

                    const spotId = popupImage.dataset.spotId;
                    if (spotId && this.spotsData.has(spotId)) {
                        const spotData = this.spotsData.get(spotId);
                        MapService.map.closePopup();
                        this.onMarkerClick(spotId, spotData);
                    }
                });
            },
            
            setupPopupNoteClickHandler() {
                document.addEventListener('click', (e) => {
                    const popupNote = e.target.closest('.popup-note');
                    if (!popupNote) return;

                    const spotId = popupNote.dataset.spotId;
                    if (spotId && this.spotsData.has(spotId)) {
                        const spotData = this.spotsData.get(spotId);
                        MapService.map.closePopup();
                        this.onMarkerClick(spotId, spotData);
                    }
                });
            },

            setupReactionHandler() {
                document.addEventListener('click', async (e) => {
                    const button = e.target.closest('.reaction-btn');
                    if (!button) return;
                    if (!FirebaseService.userId) {
                        alert("You need to be signed in to react.");
                        return;
                    }

                    const spotId = button.dataset.spotId;
                    const newReaction = button.dataset.reaction;

                    try {
                        const spotDoc = await FirebaseService.getSpot(spotId);
                        if (!spotDoc.exists()) { return; }
                        
                        const spotData = spotDoc.data();
                        const voters = spotData.voters || {};
                        const previousReaction = voters[FirebaseService.userId];
                        
                        // --- Optimistic UI Update ---
                        const reactionContainer = button.parentElement;
                        const oldBtn = previousReaction ? reactionContainer.querySelector(`[data-reaction="${previousReaction}"]`) : null;
                        const newBtn = button;

                        // Un-reacting
                        if (newReaction === previousReaction) {
                            newBtn.classList.remove('selected');
                            const countSpan = newBtn.querySelector('span:last-child');
                            countSpan.textContent = parseInt(countSpan.textContent) - 1;
                        } 
                        // Changing reaction
                        else if (previousReaction) {
                            if (oldBtn) {
                                oldBtn.classList.remove('selected');
                                let countSpan = oldBtn.querySelector('span:last-child');
                                countSpan.textContent = parseInt(countSpan.textContent) - 1;
                            }

                            newBtn.classList.add('selected');
                            let countSpan = newBtn.querySelector('span:last-child');
                            countSpan.textContent = parseInt(countSpan.textContent) + 1;
                        }
                        // New reaction
                        else {
                             newBtn.classList.add('selected');
                             const countSpan = newBtn.querySelector('span:last-child');
                             countSpan.textContent = parseInt(countSpan.textContent) + 1;
                        }
                        
                        // --- Update Database ---
                        await FirebaseService.updateReaction(spotId, newReaction, previousReaction);
                        console.log(`Reaction updated from ${previousReaction} to ${newReaction === previousReaction ? null : newReaction}`);

                    } catch (error) {
                        console.error("Error updating reaction:", error);
                        // Optional: Revert UI changes on failure
                    }
                });
            }
        };

        // --- Application Initialization ---
        window.onload = () => {
            App.init();
        };

    </script>
</body>
</html>

